#include "fluidloom/parsing/codegen/OpenCLPreambleGenerator.h"
#include "fluidloom/parsing/registry/LatticeRegistry.h"
#include "fluidloom/parsing/registry/ConstantRegistry.h"
#include "fluidloom/core/registry/FieldRegistry.h"
#include <fstream>
#include <sstream>

namespace fluidloom {
namespace parsing {

std::string OpenCLPreambleGenerator::generate() const {
    std::ostringstream oss;
    
    oss << "// Auto-generated OpenCL preamble\n";
    oss << "// DO NOT EDIT - Generated by FluidLoom DSL Parser\n\n";
    
    // Constants
    oss << generateConstants();
    oss << "\n";
    
    // Lattice definitions
    oss << generateLatticeDefinitions();
    oss << "\n";
    
    // Field access macros
    oss << generateFieldAccessMacros();
    
    return oss.str();
}

bool OpenCLPreambleGenerator::generateToFile(const std::string& output_path) const {
    std::ofstream file(output_path);
    if (!file.is_open()) {
        return false;
    }
    
    file << generate();
    file.close();
    return true;
}

std::string OpenCLPreambleGenerator::generateFieldAccessMacros() const {
    std::ostringstream oss;
    oss << "// Field access macros\n";
    
    auto& registry = registry::FieldRegistry::instance();
    auto names = registry.getAllNames();
    
    for (const auto& name : names) {
        std::string upper_name = name;
        std::transform(upper_name.begin(), upper_name.end(), upper_name.begin(), ::toupper);
        
        // Generate macro: #define NAME(idx) name[idx]
        oss << "#define " << upper_name << "(idx) " << name << "[idx]\n";
    }
    
    return oss.str();
}

std::string OpenCLPreambleGenerator::generateLatticeDefinitions() const {
    auto& lattice_reg = LatticeRegistry::getInstance();
    return lattice_reg.generateOpenCLPreamble();
}

std::string OpenCLPreambleGenerator::generateConstants() const {
    auto& const_reg = ConstantRegistry::getInstance();
    return const_reg.generateOpenCLDefines();
}

} // namespace parsing
} // namespace fluidloom
