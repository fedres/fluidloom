// Pack kernel for SOA field data into contiguous buffer
// Supports both direct copy and trilinear interpolation

#include "fluidloom_preamble.cl"  // Generated by Module 6
#include "interpolation_constants.cl"  // Interpolation LUT

// Kernel signature
__kernel void pack_halo(
    __global const float* field_data,           // Source field SOA array
    __global const uint* local_cell_indices,    // List of local cell indices to pack
    __global const uchar* levels,               // cell_level array
    __global GhostRange* ghost_ranges,          // Metadata for this GPU
    __global float* pack_buffer,                // Destination buffer (A or B)
    __constant TrilinearParams* interp_params,  // Interpolation parameters
    const uint range_id,                        // Which GhostRange to process
    const uint field_idx,                       // Field index in registry
    const uint num_components                   // 1 for scalar, 3 for vector, etc.
) {
    const uint gid = get_global_id(0);
    const uint range_offset = ghost_ranges[range_id].pack_offset / sizeof(float);
    const uint num_cells = ghost_ranges[range_id].num_cells;
    
    if (gid >= num_cells) return;
    
    // Get local cell index from cached list
    const uint cell_idx = local_cell_indices[gid];
    const uint pack_idx = range_offset + gid * num_components;
    
    // Check if interpolation is needed
    if (ghost_ranges[range_id].requires_interpolation) {
        // Trilinear interpolation: gather from 8 coarse cells
        const uint local_level = levels[cell_idx];
        const uint remote_level = ghost_ranges[range_id].remote_level;
        
        if (remote_level < local_level) {
            // Coarse → Fine (local is finer): Interpolate from coarse neighbors
            trilinear_interpolate(field_data, cell_idx, pack_buffer + pack_idx, 
                                interp_params, num_components);
        } else {
            // Fine → Coarse: Average 8 fine cells (handled in reverse direction)
            // This case shouldn't happen in pack, only in unpack
            for (uint comp = 0; comp < num_components; ++comp) {
                pack_buffer[pack_idx + comp] = field_data[cell_idx * num_components + comp];
            }
        }
    } else {
        // Direct copy (levels match)
        for (uint comp = 0; comp < num_components; ++comp) {
            pack_buffer[pack_idx + comp] = field_data[cell_idx * num_components + comp];
        }
    }
}
